from telegram.ext import Application
from telegram.ext import MessageHandler
from telegram.ext import filters
from telegram.ext import CallbackQueryHandler
from telegram.ext import CommandHandler
from telegram import InlineKeyboardMarkup
from telegram import InlineKeyboardButton
from telegram import ReplyKeyboardMarkup
from telegram import ReplyKeyboardRemove
import requests
import sys
import random
import logging

with open('goroda.txt', encoding='utf-8') as txt:
    TOWNS = txt.readlines()

logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.DEBUG)

logger = logging.getLogger(__name__)

reply_keyboard = [['üéÆplay', 'üìästatistics'], ['üìñfaq', 'üö™exit']]
markup = ReplyKeyboardMarkup(reply_keyboard, resize_keyboard=True, one_time_keyboard=False)


async def start(update, context):
    await update.message.reply_text(
        "–Ø –±–æ—Ç-–∏–≥—Ä–∞! –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—ã –¥–ª—è —Å—Ç–∞—Ä—Ç–∞ –∏–≥—Ä—ã!",
        reply_markup=markup
    )
    return context


async def close_keyboard(update):
    await update.message.reply_text(
        "–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –∑–∞–∫—Ä—ã—Ç–∞. –ò—Å–ø–æ—å–∑—É–π—Ç–µ /start –¥–ª—è –µ—ë –∑–∞–ø—É—Å–∫–∞!",
        reply_markup=ReplyKeyboardRemove()
    )


async def helpp(update):
    await update.message.reply_text(
        "–Ø –±–æ—Ç, –∫–æ–º–∞–Ω–¥–∞ –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ.")


async def stat(update):
    await update.message.reply_text("–í —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ.")


async def search(towngg):
    geocoder_request = (f"http://geocode-maps.yandex.ru/1.x/?apikey=40d1649f-0"
                        f"493-4b70-98ba-98533de7710b&geocode={towngg}&format=json")
    response = requests.get(geocoder_request)
    if not response:
        print("–û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∑–∞–ø—Ä–æ—Å–∞:")
        return [1000 - 7]
    json_response = response.json()
    toponym = json_response["response"]["GeoObjectCollection"]["featureMember"][0]["GeoObject"]
    toponym_coodrinates = toponym["Point"]["pos"]
    return ','.join(toponym_coodrinates.split(' '))


async def play(update, context):
    town = random.choice(TOWNS)[:-1]
    cords = await search(town)
    map_request = f"http://static-maps.yandex.ru/1.x/?ll={cords}&spn=0.05,0.05&l=sat"
    response = requests.get(map_request)
    if not response:
        print("–û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∑–∞–ø—Ä–æ—Å–∞:")
        sys.exit(1)
    map_file = "map.png"
    with open(map_file, "wb") as file:
        file.write(response.content)
    await update.message.reply_text(
        "–ü—Ä–∏–≤–µ—Ç. –£–≥–∞–¥–∞–π—Ç–µ –≥–æ—Ä–æ–¥ –ø–æ —Ñ–æ—Ç–æ:")
    await update.message.reply_photo('map.png')
    await update.message.reply_text(
        "–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –≥–æ—Ä–æ–¥–∞:")
    context.user_data['locality'] = [town, cords]
    context.user_data['isgame'] = 'wait town'


async def first_response(update, context):
    context.user_data['locality'] = context.user_data['locality'] + [update.message.text]
    s = context.user_data['locality']
    try:
        cords2 = await search(context.user_data['locality'][2])
    except Exception as error:
        logging.exception(error)
        cords2 = '123'
    await update.message.reply_text(f'–í—ã —É–≥–∞–¥–∞–ª–∏ –≥–æ—Ä–æ–¥ - {s[0]}\n–æ—Ü–µ–Ω–∏—Ç–µ –∏–≥—Ä—É –æ—Ç 1 –¥–æ 5' if cords2 == s[
        1] else f'–í—ã –Ω–µ —É–≥–∞–¥–∞–ª–∏ –≥–æ—Ä–æ–¥ {s[0]}, –≤—ã–±—Ä–∞–≤ - {s[2]}\n–æ—Ü–µ–Ω–∏—Ç–µ –∏–≥—Ä—É –æ—Ç 1 –¥–æ 5')
    context.user_data['isgame'] = 'wait number'


async def second_response(update, context):
    await update.message.reply_text(f"–°–ø–∞—Å–∏–±–æ –∑–∞ —É—á–∞—Å—Ç–∏–µ! –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ!")
    del context.user_data['isgame']
    del context.user_data['locality']


async def check_command(update, context):
    if 'isgame' in context.user_data:
        if context.user_data['isgame'] == 'wait town':
            await first_response(update, context)
        elif context.user_data['isgame'] == 'wait number':
            await second_response(update, context)
    elif update.message.text == 'üéÆplay':
        await play(update, context)
    elif update.message.text == 'üìästatistics':
        await stat(update)
    elif update.message.text == 'üìñfaq':
        await helpp(update)
    elif update.message.text == 'üö™exit':
        await close_keyboard(update)
    elif update.message.text == 'ke':
        await first_key_buttons(update)


async def first_key_buttons(update):
    keyboard = [
        [
            InlineKeyboardButton("1", callback_data=str('1')),
            InlineKeyboardButton("2", callback_data=str('2')),
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("Start handler, Choose a route", reply_markup=reply_markup)


async def second_key_buttons(update, context):
    """Show new choice of buttons"""
    query = update.callback_query
    await query.answer()
    keyboard = [
        [
            InlineKeyboardButton("3", callback_data=str(3)),
            InlineKeyboardButton("4", callback_data=str(4)),
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text(
        text="First CallbackQueryHandler, Choose a route", reply_markup=reply_markup
    )
    return context


def main():
    application = Application.builder().token('7198751024:AAF8hG5IUJq-BNMJ6BQ0FtH6kQgUDdT7C7I').build()

    application.add_handler(CommandHandler("start", start))

    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, check_command))

    application.add_handler(CallbackQueryHandler(second_key_buttons, pattern="^" + str(1) + "$"))

    application.run_polling()


if __name__ == '__main__':
    main()
